module iproute2-ip-link {
    yang-version 1.1;
    namespace "urn:okda:iproute2:ip:link";
    prefix iplink;

    import ietf-inet-types { prefix inet; }
    import ietf-yang-types { prefix yang;}
    import iproute2-cmdgen-extensions { prefix ipr2cgen; }
    import iproute2-ip-netns { prefix ipnetns; }

    organization
        "Okda Networks";

    contact
        "Author: Ali Aqrabawi
        <aaqrabaw@okdanetworks.com>";

    description

        "This module contain the iproute2 'ip link' configurations ,
        this is module contains all IP-LINK (8) related configs,
        refer to https://manpages.debian.org/unstable/iproute2/ip-link.8.en.html";

    revision "2024-02-13" {
        description "Revision 1";
        reference
            "YANG model for iproute2 ip link case.";
    }

    /*
    * Typedefs
    */

    typedef ipv4-with-cider{
    // we can't use inet, as libyang does subnetting to inet:ipv4-prefix.
        type string {
            pattern
                '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}'
                +  '([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
                + '/(([0-9])|([1-2][0-9])|(3[0-2]))';
        }
        description
            "ipv4 address with mask, e.g: 192.168.1.1/24";
    }
    typedef ipv6-with-cider {
        type string {
            pattern '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}'
            + '((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|'
            + '(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}'
            + '(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))'
            + '(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))';
            pattern '(([^:]+:){6}(([^:]+:[^:]+)|(.*\..*)))|'
            + '((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)'
            + '(/.+)';
        }
        description
            "ipv6 address with mask, e.g: 201::4/64";
    }
    typedef ip-address-with-cider {
        type union {
            type ipv4-with-cider;
            type ipv6-with-cider;
        }
        description
            "The ip-prefix type represents an IP prefix and is IP
            version neutral.  The format of the textual representations
            implies the IP version.";
    }
    typedef vrf-ref {
        type leafref {
            path "/iplink:links/iplink:vrf/iplink:name";
        }
        description
            "This type is used by data models that need to reference
            interfaces.";
    }
    typedef link-ref {
        type leafref {
            path "/iplink:links/iplink:link/iplink:name";
        }
        description
            "This type is used by data models that need to reference
            interfaces.";
    }
    typedef vti-ref {
        type leafref {
            path "/iplink:links/iplink:vti/iplink:name";
        }
        description
            "This type is used by data models that need to reference
            interfaces.";
    }
    typedef vlan-ref {
        type leafref {
            path "/iplink:links/iplink:vlan/iplink:name";
        }
        description
            "This type is used by data models that need to reference vlan
            interfaces.";
    }
    typedef vxlan-ref {
        type leafref {
            path "/iplink:links/iplink:vxlan/iplink:name";
        }
        description
            "This type is used by data models that need to reference vlan
            interfaces.";
    }
    typedef bridge-ref {
        type leafref {
            path "/iplink:links/iplink:bridge/iplink:name";
        }
        description
            "This type is used by data models that need to reference bridge
            interfaces.";
    }
    typedef gre-ref {
        type leafref {
            path "/iplink:links/iplink:gre/iplink:name";
        }
        description
            "This type is used by data models that need to reference gre
            interfaces.";
    }
    typedef bond-ref {
        type leafref {
            path "/iplink:links/iplink:bond/iplink:name";
        }
        description
            "This type is used by data models that need to reference bond
            interfaces.";
    }
    typedef l3-links-ref {
        type union{
            type link-ref;
            type bond-ref;
            type vti-ref;
            type gre-ref;
            type vlan-ref;
            type vxlan-ref;
            type bridge-ref;
        }
    }
    typedef all-links-ref {
        type union{
            type link-ref;
            type bond-ref;
            type vti-ref;
            type gre-ref;
            type bridge-ref;
            type vrf-ref;
            type vlan-ref;
            type vxlan-ref;
        }
    }

    /*
    * Identities
    */

    identity link-type {
        description
            "Base identity for ip link types.";
    }

    identity oper-link-type {
        description
            "Base identity for non-configurable ip link types.";
    }

    //    identity bond {
    //        base link-type;
    //        description
    //            "Bonding device.";
    // }

    identity can {
        base link-type;
        description
            "Controller Area Network.";
    }

    identity dsa {
        base link-type;
        description
            "Distributed Switch Architecture.";
    }

    identity dummy {
        base link-type;
        description
            "Dummy network interface.";
    }

    identity gretap {
        base link-type;
        description
            "Virtual L2 tunnel interface GRE over IPv4.";
    }

    identity ifb {
        base link-type;
        description
            "Intermediate Functional Block device.";
    }

    identity ip6tnl {
        base link-type;
        description
            "Virtual tunnel interface IPv4|IPv6 over IPv6.";
    }

    identity ipvlan {
        base link-type;
        description
            "Interface for L3 (IPv6/IPv4) based VLANs.";
    }

    identity ipvtap {
        base link-type;
        description
            "Interface for L3 (IPv6/IPv4) based VLANs and TAP.";
    }

    identity lowpan {
        base link-type;
        description
            "Interface for 6LoWPAN (IPv6) over IEEE 802.15.4 / Bluetooth.";
    }

    identity netdevsim {
        base link-type;
        description
            "Interface for netdev API tests.";
    }

    identity nlmonipvtap {
        base link-type;
        description
            "Netlink monitoring device.";
    }

    identity vcan {
        base link-type;
        description
            "Virtual Controller Area Network interface.";
    }

    identity virt_wifi {
        base link-type;
        description
            "rtnetlink wifi simulation device.";
    }

    identity veth {
        base link-type;
        description
            "veth device.";
    }

    identity vxcan {
        base link-type;
        description
            "vxcan device.";
    }

    identity erspan {
        base link-type;
        description
            "erspan device.";
    }

    identity ip6erspan {
        base link-type;
        description
            "erspan device.";
    }

    identity ether {
        base oper-link-type;
        description
            "ethernet device.";
    }
    identity tun {
        base link-type;
        description
            "tun device. can't be changed";
    }

    identity loopback {
        base oper-link-type;
        description
            "loopback device.";
    }

    /*
    * groupings
    */

    grouping link-essentials{

        leaf mtu {
            type uint32{
                range "64..65575";
            }
            default 1500;
            description "specifies the mtu size for the device";
        }
        leaf admin-status{
            description "set admin status for the link";
            ipr2cgen:value-only;
            ipr2cgen:oper-arg-name "flags";
            ipr2cgen:oper-flag-map '{"UP":"up", "FLAG-UNSET":"down"}';
            type enumeration {
                enum "up";
                enum "down";
            }
            default "down";
        }
        leaf index {
            ipr2cgen:oper-arg-name "ifindex";
            type uint64;
            description "specifies the desired index of the new virtual device.
            The link creation fails, if the index is busy.";
        }
        leaf netns {
            ipr2cgen:arg-name "netns";
            type union {
                type ipnetns:netns-ref;
                type enumeration {
                    enum "1";
                }
            }
            default "1";
            description "network namespace name";
        }
        leaf group {
            description "specify group id that this link belong to,
            GROUP has a dual role: If both group and dev are present,
            then move the device to the specified group. If only a group is specified,
            then the change operates on all devices in that group.";
            ipr2cgen:oper-value-map '{"default": "0"}';
            type uint64;
            default 0;
        }
    }

    grouping link-advance {
        leaf master{
            ipr2cgen:on-node-delete-or-val-false "nomaster";
            type union {
                type bond-ref;
                type bridge-ref;
                type vrf-ref;
            }
            description "add the link to master link";
            must "../master != ../name" {
                error-message "cannot use same link as master link!";
            }
            must "(/links/bond[name=current()/../master]) or (/links/bridge[name=current()/../master])
            or (/links/vrf[name=current()/../master])" {
                error-message "The master type must be 'bond' 'bridge', or 'vrf'.";
            }
            must "(../netns = /links/bond[name=current()/../master]/netns) or (../netns = /links/bridge[name=current()/../master]/netns)
            or (../netns = /links/vrf[name=current()/../master]/netns) " {
                error-message "netns mismatch: the specified 'master' netns must be the same as currnt link netns"; }
        }
        container advance {
            leaf protodown {
                description "change the PROTODOWN state on the device.
                Indicates that a protocol error has been detected on the port.
                Switch drivers can react to this error by doing a phys down on the switch port.";
                type enumeration {
                    enum "on";
                    enum "off";
                }
                default "on";
            }
            leaf numtxqueues {
                ipr2cgen:oper-arg-name "num_tx_queues";
                type uint32;
                default 1;
                description "specifies the number of transmit queues for device.";
            }
            leaf numrxqueues {
                ipr2cgen:oper-arg-name "num_rx_queues";
                type uint32;
                default 1;
                description "specifies the number of receive queues for device.";
            }
            leaf gso_max_size {
                type uint32;
                default 65536;
                description "BYTES: specifies the recommended maximum size of a Generic Segment Offload packet
                the new device should accept. This is also used to enable BIG TCP for IPv6 on
                this device when the size is greater than 65536.";
            }
            leaf gso_ipv4_max_size {
                type uint32;
                default 65536;
                description "BYTES: specifies the recommended maximum size of a IPv4 Generic Segment Offload
                packet the new device should accept. This is especially used to enable BIG TCP for
                IPv4 on this device by setting to a size greater than 65536.";
            }
            leaf gso_max_segs {
                type uint32;
                default 65535;
                description "specifies the recommended maximum number of a Generic Segment
                Offload segments the device should accept.";
            }
            leaf gro_max_size {
                type uint32;
                default 65536;
                description "specifies the maximum size of a packet built by GRO stack on this device.
                This is also used for BIG TCP to allow the size of a merged IPv6 GSO
                packet on this device greater than 65536.";
            }
            leaf gro_ipv4_max_size {
                type uint32;
                default 65536;
                description "specifies the maximum size of a IPv4 packet built by GRO stack on this device.
                This is especially used for BIG TCP to allow the size of a merged IPv4 GSO packet on
                this device greater than 65536.";
            }
            leaf txqueuelen {
                description "change the transmit queue length of the device.";
                ipr2cgen:oper-arg-name "txqlen";
                type uint32;
                default 1000;
            }
        }
        container modes {
            description "set arb,mcast,promsi ... etc modes on the link";
            leaf arp {
                description "change the NOARP flag on the device.";
                ipr2cgen:oper-arg-name "flags";
                ipr2cgen:oper-flag-map '{"NOARP":"off", "FLAG-UNSET":"on"}';
                type enumeration {
                    enum "on";
                    enum "off";
                }
                default "on";
            }
            leaf multicast {
                description "change the MULTICAST flag on the device.";
                ipr2cgen:oper-arg-name "flags";
                ipr2cgen:oper-flag-map '{"MULTICAST":"on", "FLAG-UNSET":"off"}';
                type enumeration {
                    enum "on";
                    enum "off";
                }
                default "off";
            }
            leaf allmulticast {
                description "change the ALLMULTI flag on the device. When enabled,
                instructs network driver to retrieve all multicast packets from the network
                to the kernel for further processing.";
                ipr2cgen:oper-arg-name "flags";
                ipr2cgen:oper-flag-map '{"ALLMULTI":"on", "FLAG-UNSET":"off"}';
                type enumeration {
                    enum "on";
                    enum "off";
                }
                default "off";
            }
            leaf promisc {
                ipr2cgen:oper-arg-name "promiscuity";
                ipr2cgen:oper-value-map '{"0":"off", "1":"on", "2":"on"}';
                type enumeration {
                    enum "on";
                    enum "off";
                }
                description "change the PROMISC flag on the device. When enabled,
                activates promiscuous operation of the network device.";
                default "off";
            }
            leaf trailers {
                description "change the NOTRAILERS flag on the device,
                NOT used by the Linux and exists for BSD compatibility";
                ipr2cgen:oper-arg-name "flags";
                ipr2cgen:oper-flag-map '{"NOTRAILERS":"off", "FLAG-UNSET":"on"}';
                type enumeration {
                    enum "on";
                    enum "off";
                }
                default "on";
            }
        }
    }

    grouping link-layer2{
        container lladdresses {
            description "configure lladdress for link, peer and broadcast addresses";
            leaf mac_addr{
                ipr2cgen:arg-name "address";
                ipr2cgen:oper-arg-name "address";
                type yang:mac-address;
                description "change the station address of the interface.";
            }
            leaf broadcast_addr {
                ipr2cgen:arg-name "broadcast";
                ipr2cgen:oper-arg-name "broadcast";
                type yang:mac-address;
                description "change the link layer broadcast address, when the interface is POINTOPOINT.";
            }
            leaf peer_addr {
                ipr2cgen:arg-name "peer";
                ipr2cgen:oper-arg-name "peer";
                type yang:mac-address;
                description "change the link layer peer address, when the interface is POINTOPOINT.";
            }
        }
    }

    grouping link-layer3{
        list ip {
            ipr2cgen:cmd-start;
            ipr2cgen:cmd-add "ip address add";
            ipr2cgen:cmd-update "ip address replace";
            ipr2cgen:cmd-delete "ip address del";
            ipr2cgen:oper-arg-name "addr_info";
            description "link ipv4 address";
            key "address";
            leaf address {
                ipr2cgen:after-node-add-static-arg "dev (../../name)";
                ipr2cgen:value-only;
                ipr2cgen:oper-arg-name "local";
                ipr2cgen:oper-combine-values '{"separator":"/", "values": ["local", "prefixlen"]}';
                description "ip address with cider, e.g 192.168.1.1/24";
                type ip-address-with-cider;
            }
        }
    }

    grouping link-bridge {
        container bridge-conf {
            list vlan {
                ipr2cgen:cmd-start;
                ipr2cgen:cmd-add "bridge vlan add";
                ipr2cgen:cmd-update "bridge vlan add";
                ipr2cgen:cmd-delete "bridge vlan delete";
                ipr2cgen:replace-on-update;
                ipr2cgen:include-all-on-delete;
                ipr2cgen:oper-sub-jobj "vlans";
                must "(../../master and /links/bridge[name=current()/../../master]) or (/links/bridge[name=current()/../../name])" {
                    error-message "please set the link 'master' to a bridge, before configuring bridge vlan";
                }
                key "vid";
                leaf vid {
                    ipr2cgen:after-node-add-static-arg "dev (../../../name)";
                    ipr2cgen:oper-arg-name "vlan";
                    type uint16;
                    description
                        "specify vlan id";
                }
                leaf pvid {
                    ipr2cgen:flag;
                    ipr2cgen:oper-arg-name "flags";
                    ipr2cgen:oper-flag-map '{"PVID":"true", "FLAG-UNSET":"false"}';
                    type boolean;
                    description
                        "when enabled, this vlan will be considered a PVID at ingress.
                        Any untagged frames will be assigned to this VLAN.";
                }
                leaf untagged {
                    ipr2cgen:flag;
                    ipr2cgen:oper-arg-name "flags";
                    ipr2cgen:oper-flag-map '{"Egress Untagged":"true", "FLAG-UNSET":"false"}';
                    type boolean;
                    description
                        "the vlan specified is to be treated as untagged on egress.";
                }
                leaf self {
                    ipr2cgen:flag;
                    ipr2cgen:oper-arg-name "flags";
                    ipr2cgen:oper-flag-map '{"SELF":"true", "FLAG-UNSET":"false"}';
                    type boolean;
                    description
                        "the vlan is configured on the specified physical device.
                        Required if the device is the bridge device.";
                }
                leaf master {
                    ipr2cgen:flag;
                    ipr2cgen:oper-arg-name "flags";
                    ipr2cgen:oper-flag-map '{"MASTER":"true", "FLAG-UNSET":"false"}';
                    type boolean;
                    description
                        "the vlan is configured on the software bridge (default).";
                }

            }
            container link {
                when "../../master and /links/bridge[name=current()/../../master]";
                ipr2cgen:oper-sub-jobj "info_slave_data";
                ipr2cgen:add-static-arg "type bridge_slave";
                leaf state {
                    description "Set port state.";
                    type enumeration {
                        enum "disabled" {value 0;}
                        enum "listening" {value 1;}
                        enum "learning" {value 2;}
                        enum "forwarding" {value 3;}
                        enum "blocking" {value 4;}

                    }
                }
                leaf cost {
                    type uint32;
                    description "the STP path cost of the specified port";
                }
                leaf priority {
                    type uint8;
                    description "the STP port priority. The priority value is an unsigned
                    8-bit quantity (number between 0 and 255). This metric is
                    used in the designated port an droot port selection
                    algorithms";
                }
                leaf guard {
                    ipr2cgen:oper-value-map '{"true":"on", "false":"off"}';
                    type enumeration {
                        enum "on";
                        enum "off";
                    }
                    description "block incoming BPDU packets on this port.";
                }
                leaf hairpin {
                    ipr2cgen:oper-value-map '{"true":"on", "false":"off"}';
                    type enumeration {
                        enum "on";
                        enum "off";
                    }
                    description "enable hairpin mode on this
                    port. This will allow incoming packets on this
                    port to be reflected back.";
                }
                leaf fastleave {
                    ipr2cgen:oper-value-map '{"true":"on", "false":"off"}';
                    type enumeration {
                        enum "on";
                        enum "off";
                    }
                    description "enable multicast fast leave on this port.
                    ";
                }
                leaf root_block {
                    ipr2cgen:oper-value-map '{"true":"on", "false":"off"}';
                    type enumeration {
                        enum "on";
                        enum "off";
                    }
                    description "block this port from becoming the bridge's root port.";
                }
                leaf learning {
                    ipr2cgen:oper-value-map '{"true":"on", "false":"off"}';
                    type enumeration {
                        enum "on";
                        enum "off";
                    }
                    description "allow MAC address learning on this port.";
                }
                leaf flood {
                    ipr2cgen:oper-value-map '{"true":"on", "false":"off"}';
                    type enumeration {
                        enum "on";
                        enum "off";
                    }
                    description "open the flood gates on this
                    port, i.e. forward all unicast frames to this port
                    also. Requires proxy_arp to be
                    turned off.";
                }
                leaf proxy_arp {
                    ipr2cgen:oper-value-map '{"true":"on", "false":"off"}';
                    type enumeration {
                        enum "on";
                        enum "off";
                    }
                    description "enable proxy ARP on this port.";
                }
            }
        }
    }

    grouping link-device {
        leaf device {
            must "../device != ../name" {
                error-message "Cannot reference the current link name, you can use other links";
            }
            must "(../mtu <= /links/link[name=current()/../device]/mtu) or (../mtu <= /links/bridge[name=current()/../device]/mtu)" {
                error-message "the specified 'device' mtu must be equal or greater than currnt link mtu";
            }
            must "(../netns = /links/link[name=current()/../device]/netns) or (../netns = /links/bridge[name=current()/../device]/netns)
            or (/links/link[name=current()/../device]/type = 'iplink:veth')" {
                error-message "netns mismatch: the specified 'device' netns must be the same as currnt link netns";
            }
            ipr2cgen:arg-name "link";
            ipr2cgen:oper-arg-name "link";
            type union{
                type link-ref;
                type bridge-ref;
            }

            description "specifies the physical device to act operate on";
        }
    }

    grouping link-state {
        container state {
            config false;
            leaf-list flags {
                type enumeration {
                    enum "NO-CARRIER";
                    enum "LOOPBACK";
                    enum "BROADCAST";
                    enum "POINTOPOINT";
                    enum "MULTICAST";
                    enum "NOARP";
                    enum "ALLMULTI";
                    enum "PROMISC";
                    enum "MASTER";
                    enum "SLAVE";
                    enum "DEBUG";
                    enum "DYNAMIC";
                    enum "AUTOMEDIA";
                    enum "PORTSEL";
                    enum "NOTRAILERS";
                    enum "UP";
                    enum "LOWER_UP";
                    enum "DORMANT";
                    enum "ECHO";
                    enum "M-DOWN";
                }
                description "A list of flags representing various states and capabilities of the interface.
                Each flag denotes a specific characteristic or status";
            }
            leaf qdisc {
                type string; //TODO review
                description "Reference to the queuing discipline (qdisc) associated with the interface.";
            }
            leaf operstate {
                type enumeration {
                    enum "UP";
                    enum "DOWN";
                    enum "LOWERLAYERDOWN";
                    enum "UNKNOWN";
                    enum "NOTPRESENT";
                    enum "TESTING";
                    enum "DORMANT";
                }
                description "Represents the current operational state of the interface.";
            }
            leaf linkmode {
                type enumeration {
                    enum "DEFAULT";
                    enum "DORMANT";
                }
                description "Defines the current link mode of the interface.";
            }
            container stats64 {
                description "Contains 64-bit counters for various network statistics.
                Providing detailed information on the traffic handled by the interface.";
                container rx {
                    leaf bytes {
                        type uint64;
                        description "Total number of bytes received by the interface.";
                    }
                    leaf packets {
                        type uint64;
                        description "Total number of packets received by the interface.";
                    }
                    leaf errors {
                        type uint64;
                        description "Number of receive errors detected by the interface.";
                    }
                    leaf dropped {
                        type uint64;
                        description "Number of packets dropped by the interface due to various reasons, such as buffer overflows.";
                    }
                    leaf over_errors {
                        type uint64;
                        description "Count of receiver overruns, indicating packets lost because the receiver
                        couldn't handle incoming data quickly enough.";
                    }
                    leaf multicast {
                        type uint64;
                        description "Number of multicast packets received by the interface.";
                    }
                }
                container tx {
                    leaf bytes {
                        type uint64;
                        description "Total number of bytes transmitted by the interface.";
                    }
                    leaf packets {
                        type uint64;
                        description "Total number of packets transmitted by the interface.";
                    }
                    leaf errors {
                        type uint64;
                        description "Number of transmission errors detected by the interface.";
                    }
                    leaf dropped {
                        type uint64;
                        description "Number of packets that were not transmitted by the interface and were dropped.";
                    }
                    leaf carrier_errors {
                        type uint64;
                        description "Count of carrier-related errors on the interface.
                        typically indicating problems with the physical layer.";
                    }
                    leaf collisions {
                        type uint64;
                        description "Number of collision errors detected on the interface.";
                    }
                }
            }
        }
    }

    grouping tunnel-common {
        leaf local {
            ipr2cgen:oper-value-map '{"any":"0.0.0.0"}';
            type inet:ipv4-address;
            description "specifies the fixed local ipv4 address for tunneled packets.
            It must be an address on another interface on the host.";
            default "0.0.0.0";
        }
        leaf remote {
            ipr2cgen:oper-value-map '{"any":"0.0.0.0"}';
            type inet:ipv4-address;
            description "specifies the remote ipv4 address of the tunnel.";
            default "0.0.0.0";
        }
        leaf dev {
            ipr2cgen:oper-arg-name "link";
            type link-ref;
            description "specifies the physical device to use for tunnel endpoint communication.";
        }
    }

    grouping tunnel-keyed{
        leaf ikey {
            type yang:dotted-quad;
            description "specifies the tunnel input key (dotted-quad)";
        }
        leaf okey {
            type yang:dotted-quad;
            description "specifies the tunnel output key (dotted-quad)";
        }
    }

    grouping l3-tunnel-common {

        leaf encap {
            type enumeration{
                enum "fou";
                enum "gue";
                enum "none";
            }
            description
                "specifies type of secondary UDP encapsulation. \"fou\" indicates Foo-Over-UDP, \"gue\"
                indicates Generic UDP Encapsulation.";
        }
        leaf encap-sport {
            default "auto";
            type union {
                type enumeration { enum "auto"; }
                type inet:port-number;

            }
            description
                "'auto' indicates that the port number should be chosen automatically
                (the kernel picks a flow based on the flow hash of the encapsulated packet)";
        }
        leaf encap-csum {
            type boolean;
            ipr2cgen:on-node-delete-or-val-false "noencap-remcsum ";
            ipr2cgen:flag;
            description
                "specifies if UDP checksums are enabled in the secondary encapsulation.";
        }
        leaf encap-remcsum {
            type boolean;
            ipr2cgen:on-node-delete-or-val-false "noencap-remcsum";
            ipr2cgen:flag;
            description
                "specifies if Remote Checksum Offload is enabled.
                This is only applicable for Generic UDP Encapsulation.";
        }
    }

    container links {
        description "ip-link - network device configuration";
        list vrf{
            ipr2cgen:cmd-start;
            ipr2cgen:cmd-add "ip link add";
            ipr2cgen:cmd-update "ip link set";
            ipr2cgen:cmd-delete "ip link delete";
            ipr2cgen:oper-cmd "ip address show type vrf";
            key "name";
            leaf name {
                ipr2cgen:oper-arg-name "ifname";
                type string;
                description "vrf name";
            }
            uses link-essentials;
            container vrf-info{
                ipr2cgen:add-static-arg "type vrf";
                ipr2cgen:oper-sub-jobj "info_data";
                leaf table{
                    type uint16;
                    description "vrf table id";
                    mandatory true;
                }
            }

        }
        list link {
            ipr2cgen:cmd-add "ip link add";
            ipr2cgen:cmd-update "ip link set";
            ipr2cgen:cmd-delete "ip link delete";
            ipr2cgen:cmd-start;
            ipr2cgen:oper-cmd "ip address show";
            ipr2cgen:oper-inner-cmd "bridge vlan show,ifname,vlans";
            ipr2cgen:oper-stop-if '{"info_kind": ["vti", "vlan", "vrf", "bond", "bridge", "vxlan", "gre", "sit"], 
                                    "link_type": ["tunnel6", "loopback"]}';
            key "name";
            description "ip-link - network device";
            leaf name {
                ipr2cgen:value-only-on-update;
                ipr2cgen:oper-arg-name "ifname";
                type string;
                description "link name";
            }
            uses link-device;
            uses link-essentials;
            uses link-advance;
            uses link-layer2;
            uses link-layer3;
            leaf type {
                ipr2cgen:oper-arg-name "info_kind";
                //                mandatory true;  // this should be mandatory, will be uncomment after fix #91
                type identityref {
                    base link-type;
                }
                description "specifies the type of the device";
            }
            leaf virtual_peer_name {
                ipr2cgen:arg-name "peer name";
                type string;
                description "specifies the virtual pair device name of the VETH/VXCAN tunnel.";
                must "(../iplink:type = 'iplink:veth') or (../iplink:type = 'iplink:vxcan')"{
                    error-message "virtual_peer_name can be only configured for veth or vxcan links.";
                }
            }
            uses link-bridge;
            container bond_slave {
                ipr2cgen:add-static-arg "type bond_slave";
                when "../master and /links/bond[name=current()/../master]";
                description "set additional bonding related to link with master bond link";
                leaf queue_id{
                    must "/links/link[name=current()/../../master]/type = 'iplink:bond'" {
                        error-message "queue_id can only be confirgured if the link is part of bonding
                        (has a master link or type 'bond') ";
                    }
                    type uint16;
                    description "ID - set the slave's queue ID (a 16bit unsigned value)";
                }
                leaf prio {
                    type int32;
                    description "PRIORITY - set the slave's priority for active slave re-selection
                    during failover (a 32bit signed value). This option only valid for active-backup(1),
                    balance-tlb (5) and balance-alb (6) mode.";
                }
            }
            uses link-state;
        }
        list vti {
            ipr2cgen:cmd-add "ip link add";
            ipr2cgen:cmd-update "ip link set";
            ipr2cgen:cmd-delete "ip link delete";
            ipr2cgen:cmd-start;
            ipr2cgen:oper-cmd "ip address show type vti";
            key "name";
            leaf name {
                ipr2cgen:oper-arg-name "ifname";
                type string;
                description "vti tunnel interface name";
            }
            uses link-essentials;
            uses link-advance;
            container tunnel-info{
                ipr2cgen:add-static-arg "type vti";
                ipr2cgen:oper-sub-jobj "info_data";
                description "vti tunnel info details";
                uses tunnel-common;
                uses tunnel-keyed;
                leaf fwmark{
                    type string {
                        pattern '0x[0-9a-fA-F]+|\d+';
                    }
                    description "specify the fwmark value (0x0..0xffffffff)";
                }
            }
            uses link-state;
        }
        list vlan {
            ipr2cgen:cmd-add "ip link add";
            ipr2cgen:cmd-update "ip link set";
            ipr2cgen:cmd-delete "ip link delete";
            ipr2cgen:cmd-start;
            ipr2cgen:oper-cmd "ip address show type vlan";
            ipr2cgen:oper-inner-cmd "bridge vlan show,ifname,vlans";
            key "name";
            leaf name {
                ipr2cgen:oper-arg-name "ifname";
                type string;
                description "vlan name";
            }
            uses link-essentials;
            uses link-advance;
            uses link-device;
            uses link-layer2;
            uses link-layer3;
            container vlan-info {
                ipr2cgen:oper-sub-jobj "info_data";
                ipr2cgen:add-static-arg "type vlan";
                must "../iplink:device" {
                    description "VLAN configuration requires 'device' to be set";
                    error-message "VLAN configuration is not allowed without specifying 'device'";
                }
                description "vlan type interface paramters";
                leaf protocol {
                    ipr2cgen:oper-value-map '{"802.1Q":"802.1q","802.1AD":"802.1ad"}';
                    description "VLAN_PROTO - either 802.1Q or 802.1ad.";
                    default "802.1q";
                    type enumeration {
                        enum "802.1q";
                        enum "802.1ad";
                    }
                }
                leaf id {
                    type uint16;
                    description "VLAN ID";
                }
                leaf reorder_hdr {
                    ipr2cgen:oper-arg-name "flags";
                    ipr2cgen:oper-flag-map '{"REORDER_HDR":"on", "FLAG-UNSET":"off"}';
                    description "{ on | off } - specifies whether ethernet headers are reordered or not (default is on).";
                    type enumeration {
                        enum "on";
                        enum "off";
                    }
                }
                leaf gvrp {
                    ipr2cgen:oper-arg-name "flags";
                    ipr2cgen:oper-flag-map '{"GVRP":"on", "FLAG-UNSET":"off"}';
                    description "{ on | off } - specifies whether this VLAN should be
                    registered using GARP VLAN Registration Protocol.";
                    type enumeration {
                        enum "on";
                        enum "off";
                    }
                }
                leaf mvrp {
                    ipr2cgen:oper-arg-name "flags";
                    ipr2cgen:oper-flag-map '{"MVRP":"on", "FLAG-UNSET":"off"}';
                    description "{ on | off } - specifies whether this VLAN should be registered
                    using Multiple VLAN Registration Protocol.";
                    type enumeration {
                        enum "on";
                        enum "off";
                    }
                }
                leaf loose_binding {
                    ipr2cgen:oper-arg-name "flags";
                    ipr2cgen:oper-flag-map '{"LOOSE_BINDING":"on", "FLAG-UNSET":"off"}';
                    description "{ on | off } - specifies whether the VLAN device state is bound to the
                    physical device state.";
                    type enumeration {
                        enum "on";
                        enum "off";
                    }
                }
                leaf bridge_binding {
                    ipr2cgen:oper-arg-name "flags";
                    ipr2cgen:oper-flag-map '{"BRIDGE_BINDING":"on", "FLAG-UNSET":"off"}';
                    description "{ on | off } - specifies whether the VLAN device link state tracks the state
                    of bridge ports that are members of the VLAN.";
                    type enumeration {
                        enum "on";
                        enum "off";
                    }
                }
                leaf-list ingress-qos-map {
                    type string {
                        pattern '\d+:\d+';
                    }
                    description "defines a mapping of VLAN header prio field to the Linux internal packet priority on
                    incoming frames. The format is FROM:TO with multiple mappings separated by spaces.";
                }
                leaf-list egress-qos-map {
                    type string {
                        pattern '\d+:\d+';
                    }
                    description "defines a mapping of Linux internal packet priority to VLAN header prio field but
                    for outgoing frames.The format is FROM:TO with multiple mappings separated by spaces.";
                }
            }
            uses link-state;
        }
        list vxlan {
            ipr2cgen:cmd-add "ip link add";
            ipr2cgen:cmd-update "ip link set";
            ipr2cgen:cmd-delete "ip link delete";
            ipr2cgen:cmd-start;
            ipr2cgen:oper-cmd "ip address show type vxlan";
            ipr2cgen:oper-inner-cmd "bridge vlan show,ifname,vlans";
            key "name";
            leaf name {
                ipr2cgen:oper-arg-name "ifname";
                type string;
                description "vxlan name";
            }
            uses link-essentials;
            uses link-advance;
            uses link-device;
            uses link-layer2;
            uses link-bridge;
            container vxlan-info {
                ipr2cgen:add-static-arg "type vxlan";
                ipr2cgen:oper-sub-jobj "info_data";
                description "vxlan configurations";
                leaf id {
                    type uint64;
                    mandatory true;
                    description
                        "VNI - specifies the VXLAN Network Identifier (or VXLAN Segment Identifier) to use.";
                }
                leaf dev {
                    ipr2cgen:oper-arg-name "link";
                    // workaround until issue #2211 in libyang is fixed
                    type union{
                        type iplink:link-ref;
                        type iplink:vti-ref;
                        type iplink:gre-ref;
                        type iplink:bridge-ref;
                        type iplink:vlan-ref;
                        type iplink:bond-ref;
                    }
                    description
                        "PHYS_DEV - specifies the physical device to use for tunnel endpoint communication.";
                }
                choice remote-or-grp {
                    case mcast-group{
                        leaf group {
                            must "../dev"{ error-message "vxlan-info 'dev' leaf is required when 'group' is specified."; }
                            type inet:ip-address;
                            description
                                "IPADDR - specifies the multicast IP address to join.";
                        }

                    }
                    case remote-address {
                        leaf remote {
                            type inet:ip-address;
                            description
                                "IPADDR - specifies the unicast destination IP address to use in outgoing packets
                                when the destination link layer address is not known in the VXLAN device forwarding database.";
                        }
                    }
                }
                leaf local {
                    type inet:ip-address;
                    description
                        "IPADDR - specifies the source IP address to use in outgoing packets.";
                    default "0.0.0.0";
                }
                leaf ttl {
                    type uint8{
                        range "0..255";
                    }
                    description
                        "TTL - specifies the TTL value to use in outgoing packets.";
                    default 0;
                }
                leaf tos {
                    type string {
                        pattern '([0-9A-Fa-f]{2}){1}';
                    }
                    description
                        "TOS - specifies the TOS value to use in outgoing packets.";
                    default "00";
                }
                leaf df {
                    type enumeration {
                        enum "set";
                        enum "unset";
                        enum "inherit";

                    }
                    default "unset";
                    description
                        "DF - specifies the usage of the Don't Fragment flag (DF) bit in outgoing
                        packets with IPv4 headers. The value inherit causes the bit to be copied from the original
                        IP header. The values unset and set cause the bit to be always unset or always set,
                        respectively. By default, the bit is not set.";
                }
                leaf dstport {
                    ipr2cgen:oper-arg-name "port";
                    type inet:port-number;
                    default 8472;
                    description
                        "PORT - specifies the UDP destination port to communicate to the remote
                        VXLAN tunnel endpoint.";
                }
                leaf srcport {
                    type string {
                        pattern '\d+\s+\d+';
                    }
                    default "0 0";
                    description
                        "MIN MAX - specifies the range of port numbers to use as UDP source ports
                        to communicate to the remote VXLAN tunnel endpoint. example: 7770 7779";
                }
                leaf learning {
                    ipr2cgen:on-node-delete-or-val-false  "nolearning";
                    ipr2cgen:flag;
                    type boolean;
                    description
                        "specifies if unknown source link layer addresses and IP addresses are entered
                        into the VXLAN device forwarding database.";

                }
                leaf rsc {
                    ipr2cgen:on-node-delete-or-val-false "norsc";
                    ipr2cgen:flag;
                    type boolean;
                    description
                        "specifies if route short circuit is turned on.";

                }
                leaf proxy {
                    ipr2cgen:on-node-delete-or-val-false "noproxy";
                    ipr2cgen:flag;
                    type boolean;
                    description
                        "specifies ARP proxy is turned on.";

                }
                leaf l2miss {
                    ipr2cgen:on-node-delete-or-val-false "nol2miss";
                    ipr2cgen:flag;
                    type boolean;
                    description
                        "specifies if netlink LLADDR miss notifications are generated.";

                }
                leaf l3miss {
                    ipr2cgen:on-node-delete-or-val-false "nol3miss";
                    ipr2cgen:flag;
                    type boolean;
                    description
                        "specifies if netlink IP ADDR miss notifications are generated.";

                }
                leaf udpcsum {
                    ipr2cgen:on-node-delete-or-val-false "noudpcsum";
                    ipr2cgen:flag;
                    ipr2cgen:oper-arg-name "udp_csum";
                    type boolean;
                    description
                        "specifies if UDP checksum is calculated for transmitted packets over IPv4.";

                }
                leaf ageing {
                    type uint32;
                    default 300;
                    description
                        "SECONDS - specifies the lifetime in seconds of FDB entries learnt by the kernel.";
                }
                leaf maxaddress {
                    ipr2cgen:oper-arg-name "limit";
                    type uint32;
                    default 10000000;
                    description
                        "NUMBER - specifies the maximum number of FDB entries.";
                }
                leaf external {
                    ipr2cgen:on-node-delete-or-val-false "noexternal";
                    ipr2cgen:flag;
                    type boolean;
                    description
                        "specifies whether an external control plane (e.g. ip route encap)
                        or the internal FDB should be used.";

                }
                leaf vnifilter {
                    ipr2cgen:on-node-delete-or-val-false "novnifilter";
                    ipr2cgen:flag;
                    type boolean;
                    description
                        "specifies whether the vxlan device is capable of vni filtering.
                        Only works with a vxlan device with external flag set. once enabled,
                        bridge vni command is used to manage the vni filtering table on the device.
                        The device can only receive packets with vni's configured in the vni filtering table.

                        ";

                }
            }
            uses link-state;
        }
        list bridge {
            ipr2cgen:cmd-start;
            ipr2cgen:cmd-add "ip link add";
            ipr2cgen:cmd-update "ip link set";
            ipr2cgen:cmd-delete "ip link delete";
            ipr2cgen:oper-cmd "ip address show type bridge";
            ipr2cgen:oper-inner-cmd "bridge vlan show,ifname,vlans";
            key "name";
            leaf name {
                ipr2cgen:oper-arg-name "ifname";
                type string;
                description "brdige name";
            }
            uses link-essentials;
            uses link-advance;
            uses link-device;
            uses link-layer2;
            uses link-layer3;
            uses link-bridge;
            container br-info {
                ipr2cgen:add-static-arg "type bridge";
                ipr2cgen:oper-sub-jobj "info_data";
                description
                    "bridge configuraions";
                leaf ageing_time {
                    type uint64;
                    default 30000;
                    description
                        "GEING_TIME - configure the bridge's FDB entries ageing time,
                        ie the number of seconds a MAC address will be kept in the FDB after
                        a packet has been received from that address. after this time has passed,
                        entries are cleaned up.";
                }
                leaf forward_delay {
                    type uint64;
                    default 1500;
                    description
                        "FORWARD_DELAY - set the forwarding delay in seconds, ie the time spent in LISTENING state
                        (before moving to LEARNING) and in LEARNING state (before moving to FORWARDING).
                        Only relevant if STP is enabled.";
                }
                leaf hello_time {
                    type uint32{
                        range "10..1000";
                    }
                    default 200;
                    description
                        "HELLO_TIME - set the time in seconds between hello packets sent by the bridge,
                        when it is a root bridge or a designated bridges. Only relevant if STP is enabled.";

                }
                leaf max_age {
                    type uint32;
                    default 2000;
                    description
                        "MAX_AGE - set the hello packet timeout, ie the time in seconds until another
                        bridge in the spanning tree is assumed to be dead, after reception of its last
                        hello message. Only relevant if STP is enabled. Valid values are between 6 and 40.";
                }
                leaf stp_state {
                    type enumeration{
                        enum 0;
                        enum 1;
                    }
                    default 0;
                    description
                        "STP_STATE - turn spanning tree protocol on (STP_STATE == 1) or off (STP_STATE == 0). for this bridge.";
                }
                leaf priority {
                    type uint16;
                    default 32768;
                    description
                        "PRIORITY - set this bridge's spanning tree priority, used during STP root bridge election.";
                }
                leaf vlan_filtering {
                    type enumeration{
                        enum 0;
                        enum 1;
                    }
                    default 0;
                    description
                        "VLAN_FILTERING - turn VLAN filtering on (VLAN_FILTERING == 0) or off (VLAN_FILTERING == 0).
                        When disabled, the bridge will not consider the VLAN tag when handling packets.";
                }
                leaf vlan_protocol {
                    type enumeration{
                        enum "802.1Q";
                        enum "802.1ad";
                    }
                    default "802.1Q";
                    description
                        "set the protocol used for VLAN filtering.";
                }
                leaf vlan_default_pvid {
                    type uint16;
                    default 1;
                    description
                        "VLAN_DEFAULT_PVID - set the default PVID (native/untagged VLAN ID) for this bridge.";
                }
                leaf vlan_stats_enabled {
                    type enumeration {
                        enum 0;
                        enum 1;
                    }
                    default 1;
                    description
                        "VLAN_STATS_ENABLED - enable (VLAN_STATS_ENABLED == 1) or disable (VLAN_STATS_ENABLED == 0)
                        per-VLAN stats accounting.";
                }
                leaf vlan_stats_per_port {
                    type enumeration {
                        enum 0;
                        enum 1;
                    }
                    default 0;
                    description
                        "VLAN_STATS_PER_PORT - enable (VLAN_STATS_PER_PORT == 1) or disable (VLAN_STATS_PER_PORT == 0)
                        per-VLAN per-port stats accounting. Can be changed only when there are no port VLANs configured.";
                }
                leaf nf_call_iptables {
                    type enumeration {
                        enum 0;
                        enum 1;
                    }
                    default 0;
                    description
                        "NF_CALL_IPTABLES - enable (NF_CALL_IPTABLES == 1) or disable
                        (NF_CALL_IPTABLES == 0) iptables hooks on the bridge.";
                }
                leaf nf_call_arptables {
                    type enumeration {
                        enum 0;
                        enum 1;
                    }
                    default 0;
                    description
                        "NF_CALL_ARPTABLES - enable (NF_CALL_ARPTABLES = 1) or disable (NF_CALL_ARPTABLES == 0)
                        arptables hooks on the bridge.";
                }
            }
            uses link-state;
        }
        list gre {
            ipr2cgen:cmd-add "ip link add";
            ipr2cgen:cmd-update "ip link set";
            ipr2cgen:cmd-delete "ip link delete";
            ipr2cgen:cmd-start;
            ipr2cgen:oper-cmd "ip address show type gre";
            ipr2cgen:oper-inner-cmd "bridge vlan show,ifname,vlans";
            key "name";
            leaf name {
                ipr2cgen:oper-arg-name "ifname";
                type string;
                description "gre tunnel interface name";
            }
            uses link-essentials;
            uses link-advance;
            container tunnel-info{
                ipr2cgen:on-update-include "tunnel-info/type";
                ipr2cgen:oper-sub-jobj "info_data";
                description "vti tunnel info details";
                leaf type {
                    type enumeration {
                        enum "gre";
                        enum "gretap";
                    }
                    default "gre";
                    description
                        "specify gre tunnel type, this can't be changed.";
                }
                uses tunnel-common;
                uses tunnel-keyed;
                leaf iseq {
                    type boolean;
                    ipr2cgen:on-node-delete-or-val-false "noiseq";
                    ipr2cgen:flag;
                    description
                        "serialize packets. The iseq flag requires that all input packets are serialized.";
                }
                leaf oseq {
                    type boolean;
                    ipr2cgen:on-node-delete-or-val-false "nooseq";
                    ipr2cgen:flag;
                    description
                        "serialize packets. The oseq flag enables sequencing of outgoing packets.";
                }
                leaf icsum {
                    type boolean;
                    ipr2cgen:on-node-delete-or-val-false "noicsum";
                    ipr2cgen:flag;
                    description
                        "generate/require checksums for tunneled packets.The icsum flag requires that all
                        input packets have the correct checksum. ";
                }
                leaf ocsum {
                    type boolean;
                    ipr2cgen:on-node-delete-or-val-false "noocsum";
                    ipr2cgen:flag;
                    description
                        "generate/require checksums for tunneled packets.
                        The ocsum flag calculates checksums for outgoing packets..";
                }
                leaf ttl {
                    type uint8{
                        range "0..255";
                    }
                    description
                        "TTL - specifies the TTL value to use in outgoing packets.";
                    default 0;
                }
                leaf tos {
                    type string {
                        pattern '([0-9A-Fa-f]{2}){1}';
                    }
                    description
                        "TOS - specifies the TOS value to use in outgoing packets.";
                    default "00";
                }
                leaf pmtudisc {
                    type boolean;
                    ipr2cgen:on-node-delete-or-val-false "nopmtudisc";
                    ipr2cgen:flag;
                    description
                        "enables Path MTU Discovery on this tunnel.
                        It is enabled by default. Note that a fixed ttl is incompatible with this option: tunneling
                        with a fixed ttl always makes pmtu discovery.";
                }
                leaf ignore-df {
                    type boolean;
                    ipr2cgen:on-node-delete-or-val-false "noignore-df";
                    ipr2cgen:flag;
                    description
                        "enables IPv4 DF suppression on this tunnel.
                        Normally datagrams that exceed the MTU will be fragmented;
                        the presence of the DF flag inhibits this, resulting instead in an ICMP Unreachable
                        (Fragmentation Required) message. Enabling this attribute causes the DF flag to be ignored.";
                }
                leaf fwmark{
                    type string {
                        pattern '0x[0-9a-fA-F]+|\d+';
                    }
                    description "specify the fwmark value (0x0..0xffffffff)";
                }

            }
            uses link-state;

        }
        list bond {
            ipr2cgen:cmd-start;
            ipr2cgen:cmd-add "ip link add";
            ipr2cgen:cmd-update "ip link set";
            ipr2cgen:cmd-delete "ip link delete";
            ipr2cgen:oper-cmd "ip address show type bond";
            ipr2cgen:oper-inner-cmd "bridge vlan show,ifname,vlans";
            key "name";
            leaf name {
                ipr2cgen:oper-arg-name "ifname";
                type string;
                description "bond name";
            }
            uses link-essentials;
            uses link-advance;
            uses link-device;
            uses link-layer2;
            container bond-info {
                ipr2cgen:add-static-arg "type bond";
                ipr2cgen:oper-sub-jobj "info_data";
                leaf mode {
                    type enumeration {
                        enum "balance-rr";
                        enum "active-backup";
                        enum "balance-xor";
                        enum "broadcast";
                        enum "802.3ad";
                        enum "balance-tlb";
                        enum "balance-alb";
                    }
                    default "balance-rr";
                    description
                        "specify the bond link mode";
                }
                leaf active_slave {
                    ipr2cgen:not-dependency;
                    type link-ref;
                    description
                        "specify the active link in active-standby mode";
                }
                leaf primary {
                    ipr2cgen:not-dependency;
                    ipr2cgen:oper-stop-if '{"mode": ["balance-rr", "802.3ad", "balance-xor", "broadcast", "balance-alb", "balance-tlb", "802.3ad"]}';
                    type link-ref;
                    must "../mode = 'active-backup'" {
                        error-message "'primary' support on active-backup bond mode only.";
                    }
                    description
                        "specifiy the primary physical link for the bond";

                }
                leaf arp_ip_target { // TODO: this should be leaflist, but still not supported.
                    ipr2cgen:oper-arg-name "not-supported";
                    type inet:ip-address;
                    description
                        "Specifies the target IP address of ARP requests when the arp_interval parameter is enabled";
                }
                leaf miimon {
                    type uint32;
                    description
                        "Specifies (in milliseconds) how often MII link monitoring occurs.
                        This is useful if high availability is required because MII is used to verify that the NIC is active.";

                }
                leaf updelay {
                    ipr2cgen:oper-stop-if  '{"mode": ["balance-rr", "active-backup", "balance-xor", "broadcast"]}';
                    must "(../mode = '802.3ad') or (../mode = 'balance-tlb') or (../mode = 'balance-alb')" {
                        error-message "updelay support on 802.3ad, balance-tlb or balance-alb bond modes only.";
                    }
                    type uint32;
                    description
                        "Specifies (in milliseconds) how long to wait before enabling a link.
                        The value must be a multiple of the value specified in the miimon parameter.
                        The value is set to 0 by default, which disables it.";
                }
                leaf downdelay {
                    ipr2cgen:oper-stop-if  '{"mode": ["balance-rr", "active-backup", "balance-xor", "broadcast"]}';
                    must "(../mode = '802.3ad') or (../mode = 'balance-tlb') or (../mode = 'balance-alb')" {
                        error-message "'downdelay' is only supported on  802.3ad, balance-tlb or balance-alb bond modes.";
                    }
                    type uint32;
                    description
                        "Specifies (in milliseconds) how long to wait after link failure before disabling the link.
                        The value must be a multiple of the value specified in the miimon parameter.
                        The value is set to 0 by default, which disables it.";
                }
                leaf use_carrier {
                    type enumeration {
                        enum "0";
                        enum "1";
                    }
                    description
                        "Specifies whether or not miimon should use MII/ETHTOOL ioctls or netif_carrier_ok()
                        to determine the link state. The netif_carrier_ok() function relies on the device driver
                        to maintains its state with netif_carrier_on/off; most device drivers support this function.";
                }
                leaf arp_interval {
                    ipr2cgen:oper-stop-if '{"mode": ["802.3ad", "balance-tlb", "balance-alb"]}';
                    must "(../mode = 'balance-rr') or (../mode = 'active-backup') or (../mode = 'balance-xor')
                    or (../mode = 'broadcast')" {
                        error-message "'arp_interval' is only supported on balance-rr, active-backup, balance-xor or broadcast bond modes.";
                    }
                    type uint32;
                    description
                        "how often ARP monitoring occurs.";
                }
                leaf arp_validate {
                    ipr2cgen:oper-stop-if '{"mode": ["802.3ad", "balance-tlb", "balance-alb"]}';
                    must "(../mode = 'balance-rr') or (../mode = 'active-backup') or (../mode = 'balance-xor')
                    or (../mode = 'broadcast')" {
                        error-message "'arp_validate' is only supported on balance-rr, active-backup, balance-xor or broadcast bond modes.";
                    }
                    type enumeration {
                        enum "none";
                        enum "active";
                        enum "backup";
                        enum "all";
                    }
                    description
                        "Validate source/distribution of ARP probes; default is none.
                        Other valid values are active, backup, and all.";
                }
                leaf primary_reselect {
                    type enumeration {
                        enum "always";
                        enum "better";
                        enum "failure";
                    }
                    description
                        "Specifies the reselection policy for the primary port. This affects how the primary port is
                        chosen to become the active port when failure of the active port or recovery of the primary port occurs.
                        This parameter is designed to prevent flip-flopping between the primary port and other ports.
                        - always: The primary port becomes the active port whenever it comes back up.
                        - better: The primary port becomes the active port when it comes back up,
                        if the speed and duplex of the primary port is better than the speed and duplex of the current active port.
                        - failure: The primary port becomes the active port only if the current active port fails and the primary port is up.";
                }
                leaf fail_over_mac {
                    type enumeration {
                        enum "none";
                        enum "active";
                    }
                    description
                        "Specifies whether active-backup mode should set all ports to the same MAC address at the point
                        of assignment (the traditional behavior), or, when enabled, perform special handling
                        of the bond's MAC address in accordance with the selected policy. Possible values are:
                        - none:  Default setting. This setting disables fail_over_mac, and causes bonding
                        to set all ports of an active-backup bond to the same MAC address at the point of assignment.
                        - active: indicates that the MAC address of the bond should always be the MAC address of the
                        currently active port. The MAC address of the ports is not changed; instead,
                        the MAC address of the bond changes during a failover.";
                }
                leaf xmit_hash_policy {
                    type enumeration {
                        enum "layer2";
                        enum "layer3+4";
                        enum "layer2+3";
                    }
                    default "layer2";
                    description
                        "Selects the transmit hash policy used for port selection in balance-xor and 802.3ad modes.";
                }
                leaf lacp_active {
                    ipr2cgen:oper-stop-if '{"mode": ["balance-rr", "active-backup", "balance-xor", "broadcast", "balance-alb", "balance-tlb"]}';
                    must "../mode = '802.3ad'" {
                        error-message "lacp_active is only supported on 802.3ad mode.";
                    }
                    ipr2cgen:oper-arg-name "ad_lacp_active";
                    type enumeration {
                        enum "on";
                        enum "off";
                    }
                    description
                        "set the LACP active mode";
                }
                leaf lacp_rate {
                    ipr2cgen:oper-stop-if '{"mode": ["balance-rr", "active-backup", "balance-xor", "broadcast", "balance-alb", "balance-tlb"]}';
                    must "../mode = '802.3ad'" {
                        error-message "lacp_rate is only supported on 802.3ad mode.";
                    }
                    ipr2cgen:oper-arg-name "ad_lacp_rate";
                    type enumeration {
                        enum "slow";
                        enum "fast";
                    }
                    description
                        "Specifies the rate at which link partners should transmit LACPDU packets in 802.3ad mode";
                }

            }
            uses link-state;
        }
    }
}
